<?php

/**
 * URL Parsing class. Feed it a web URL and it'll do some basic
 * structural validation and extract/separate the URL's components
 * for easy reference.
 *
 * Regarding TLD extensions: the class only validates for
 * three letter domains, 2-2 letter domains (like .co.uk),
 * common longer extensions available at the time, and
 * any custom extensions you add. It does not actually validate
 * that they are 100% valid, so an extension like "qq.qq"
 * will parse just fine.
 *
 * @author		Eric "Aken" Roberts <eric@cryode.com>
 * @copyright	Copyright (c) 2012, Eric Roberts
 * @link		http://www.cryode.com Cryode Web Studio
 */
class ParseUrl {

	/**
	 * URLs without http(s):// on the front will not go through
	 * parse_url() properly. Set this option to TRUE if you want
	 * the class to add http:// for you in the event that it's missing.
	 *
	 * If set to FALSE and http(s):// is omitted, the class will
	 * throw an error.
	 *
	 * var	boolean
	 */
	protected $_forceHttp = false;
	
	/**
	 * Domain extensions that don't follow the typical
	 * 2-3 letter TLD or 2-2 (".co.uk") style domains.
	 *
	 * If you want to parse any custom domains,
	 * this is a good place to put them. Do not
	 * include any periods.
	 *
	 * var	array
	 */
	protected $_extensions = array(
		'aero', 'arpa', 'asia', 'coop', 'info', 'jobs', 'mobi',
		'museum', 'name', 'travel',
	);

	public $original;
	public $url;
	
	// Default keys generated by parse_url()
	public $scheme;
	public $host;
	public $port;
	public $user;
	public $pass;
	public $path;
	public $query; // Query strings, IE: ?item=value&another=value
	public $fragment; // Hash anchors, anything after #
	
	public $tld;
	public $domain;
	public $subdomain;
	public $subdomainArray = array();
	public $queryArray;
	
	public $isValid = true;
	public $error;
	
	/**
	 * Constructor. Does all the parsing, mkay.
	 *
	 * @return void
	 */
	public function __construct($url)
	{
		if (empty($url))
		{
			return $this->_setInvalid('No URL supplied.');
		}
		
		$this->original = $url;
		$this->url = trim(strtolower($url));
		
		// Check for http(s)
		if (substr($this->url, 0, 7) !== 'http://' && substr($this->url, 0, 8) !== 'https://')
		{
			// No http(s). Should we add it?
			if ($this->_forceHttp)
			{
				$this->url = 'http://' . $this->url;
			}
			else
			{
				return $this->_setInvalid('No http(s):// prefix on the URL.');
			}
		}
		
		// Run a typical parse_url() to break initially.
		foreach (parse_url($this->url) as $k => $v)
		{
			$this->$k = $v;
		}
		
		// Check to make sure the host exists. Shouldn't happen, but just in case...
		if (empty($this->host)) return $this->_setInvalid('Could not determine the host of the URL.');
		
		// Check our host value for any goofy characters
		// as part of a basic validation.
		if ( ! preg_match('/^[a-z0-9\-_\.]+$/', $this->host))
		{
			return $this->_setInvalid('Odd characters found in the (sub)domain.');
		}
		
		// Create a query string associative array.
		parse_str($this->query, $this->queryArray);
		
		// Get the TLD.
		// First, see if we match a 3-letter (.com) or 2.2-letter (.co.uk) TLD.
		if (preg_match('/(\.(?:[a-z]{3}|[a-z]{2}(?:\.[a-z]{2})?))$/', $this->host, $tld))
		{
			$this->tld = $tld[1];
		}
		else
		{
			// Standard format didn't match - check our array of TLD extensions.
			$ext = pathinfo($this->host, PATHINFO_EXTENSION);
			
			if (in_array($ext, $this->_extensions))
			{
				$this->tld = '.'.$ext;
			}
			else
			{
				// Nothing found.
				return $this->_setInvalid('Invalid top level domain extension.');
			}
		}
		
		// Remove subdomain from host, separate subdomain(s) from domain.
		$domain = explode('.', substr($this->host, 0, -strlen($this->tld)));
		
		$this->domain = array_pop($domain);
		
		$this->subdomain = implode('.', $domain);
		$this->subdomainArray = $domain;
	}
	
	/**
	 * Whether the provided URL is valid.
	 *
	 * @return	boolean
	 */
	public function isValid()
	{
		return (boolean) $this->isValid;
	}
	
	/**
	 * Gets the last error message, if available.
	 *
	 * @return	string
	 */
	public function getError()
	{
		return (string) $this->error;
	}
	
	/**
	 * Magic method set up to use hasProperty and getProperty functions.
	 *
	 * Calling getScheme() will return $this->scheme
	 * Calling hasScheme() will return boolean if scheme property has a value.
	 *
	 * Calling a different method, or a property that doesn't exist
	 * will thrown an exception.
	 */
	public function __call($method, $args)
	{
		$mode = strtolower(substr($method, 0, 3));
		
		$property = substr($method, 3);
		$property[0] = strtolower($property[0]);
		
		switch ($mode)
		{
			case 'get':
			
				if ($this->_hasProp($property)) return $this->$property;
				break;
			
			case 'has':
			
				if ($this->_hasProp($property))
				{
					return ! empty($this->$property);
				}
				
			default:
				throw new Exception("Unknown method '{$method}' called.");
				break;
		}
	}
	
	/**
	 * Internal method for setting the isValid to false
	 * and adding any provided error message.
	 *
	 * @return	null
	 */
	protected function _setInvalid($error = null)
	{
		$this->isValid = false;
		
		if ( ! empty($error)) $this->error = $error;
		
		return;
	}
	
	/**
	 * Internal method for checking if a property exists,
	 * and throwing an exception if it doesn't.
	 */
	protected function _hasProp($prop)
	{
		if ( ! property_exists($this, $prop))
		{
			throw new Exception("Unknown property '{$prop}' requested.");
		}
		
		return true;
	}
}

/* END ParseUrl.php */